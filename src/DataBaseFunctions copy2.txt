{-# LANGUAGE OverloadedStrings     #-}


module DataBaseFunctions where

import           Schema
import           Control.Monad.IO.Class           (liftIO, MonadIO)
import           Control.Monad.Logger        (LogLevel (..), LoggingT,
                                              filterLogger, runStdoutLoggingT)
import           Control.Monad.Reader        (ReaderT, runReaderT,forM)
import           Control.Monad.IO.Unlift
import           qualified Data.Text as T                
import           Database.Esqueleto
import           qualified Database.Persist            (Entity (..), delete, get, insert)
import           Database.Persist.Postgresql


connStr::ConnectionString
connStr = "host=localhost port=5432 user=star dbname=habot password=wader"

logFilter :: a -> LogLevel -> Bool
logFilter _ LevelError     = True
logFilter _ LevelWarn      = True
logFilter _ LevelInfo      = True
logFilter _ LevelDebug     = False
logFilter _ (LevelOther _) = False

runDb :: MonadUnliftIO m => ReaderT SqlBackend (LoggingT m) a -> m a
runDb query = do
  runStdoutLoggingT $ filterLogger logFilter $ withPostgresqlConn connStr $ \backend -> runReaderT query backend

getUserById :: Int -> IO (Maybe User)
getUserById uid = do
  runDb action
  where
    action :: SqlPersistT (LoggingT IO) (Maybe User)
    action = get $ UserKey (fromIntegral uid)

createUser :: User -> IO (Key User)
createUser user = do
  runDb action
  where
    action :: SqlPersistT (LoggingT IO) (Key User)
    action = insert user

insertMsg :: Message -> IO (Key Message)
insertMsg msg = do
  runDb action
  where
    action :: SqlPersistT (LoggingT IO) (Key Message)
    action = insert msg

insertState :: State -> IO (Key State)
insertState st = do
  runDb action
  where
    action :: SqlPersistT (LoggingT IO) (Key State)
    action = insert st

insertCountrieN :: CountriesNames -> IO (Key CountriesNames)
insertCountrieN ct = do
  runDb action
  where
    action :: SqlPersistT (LoggingT IO) (Key CountriesNames)
    action = insert ct

insertCountriesN :: [CountriesNames] -> IO (Key CountriesNames)
insertCountriesN [c] = insertCountrieN c
insertCountriesN (cx:cs) = insertCountrieN cx >> insertCountriesN cs 


{- selectAction :: SqlPersistT (LoggingT IO) (Maybe CountriesNames)
selectAction = ((fmap entityVal) . listToMaybe) <$> (select . from $ \countries_names -> do
  where_ (articles ^. CountriesNamesId ==. val (toSqlKey aid))
  return articles) -}


--https://stackoverflow.com/questions/24020739/what-is-a-correct-way-of-doing-countid-in-esqueleto-and-yesod

{- selectCount :: ReaderT backend0 m0 [Value Int]
selectCount = select $ 
              from $ \countries_names -> do
              return (countRows) -}
  


{- getCountriesN :: MonadIO m => ReaderT SqlBackend m [Single Text]
getCountriesN = rawSql "select countries_names.country from countries_names"  -}


{- convertState :: [State] -> Statedata
convertState st = head st  -}
